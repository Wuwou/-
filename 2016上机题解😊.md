# FDU2016上机题解
第一题 给定两个字符串，求最大公共字串的长度 ：  长度小于1000，两个for+string.find暴力可解
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <vector>
#include <string> 
#include <cstring>
#include <cmath>
#include <map>
#include <unordered_map>
#include <queue>
#include <stack>
#include <set>

using namespace std;

const int maxn = 1010;
int dp[maxn][maxn];
int main() {
	//freopen("input.txt", "r", stdin);
	fill(dp[0], dp[0] + maxn * maxn, 0);
	string s1, s2;
	cin >> s1 >> s2;
	int len1 = s1.length(), len2 = s2.length();
	for(int i = 0; i < len2; i++){
		dp[0][i] = 0;
	}
	for(int i = 0; i < len1; i++){
		dp[i][0] = 0;
	}
	int ans = 0;
	for(int i = 1; i <= len1; i++){
		for(int j = 1; j <= len2; j++){
			if(s1[i-1] == s2[j-1])
			{
				dp[i][j] = dp[i-1][j-1] + 1;
			}
			else{
				dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
			}
		}
	}
	cout << dp[len1][len2] << endl;
	return 0;
}
```

第二题 给定一个后缀序列，要求求值，只有加减（后缀倒是无所谓）：
   水题，后缀直接用栈做就好了，人家复试都是给前缀，要转换的
   //假如是11 13 + 15 16 - +  输出结果应该是23
 ```cpp
 
 
 ```

第三题 是给定一个字符串，求哈夫曼编码的最短长度：
    哈夫曼树做，没什么特别要注意的，有好解法，因为你会发现就是求哈夫曼树的非根结点权值之和，或者所有非叶结点之和，想通了这题异常简单，
    笨方法建树求高度乘上节点的值也可以，建立指针为叶子指向父结点的树型结构，具体题目要求忘了
